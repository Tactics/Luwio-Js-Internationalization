{"version":3,"sources":["../node_modules/moo/moo.js","../node_modules/@messageformat/parser/lib/lexer.js","../node_modules/@messageformat/parser/lib/parser.js","../node_modules/@lingui/message-utils/dist/compileMessage.mjs","../src/domain/index.tsx","../src/logger.ts","../src/context/internationalization-context.tsx","../src/hooks/use-internationalization.ts","../src/context/language-detection-context.tsx","../src/hooks/use-language-detection.ts"],"names":["parse","jsx","createContext","useContext"],"mappings":"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","file":"index.js","sourcesContent":["(function(root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define([], factory) /* global define */\n  } else if (typeof module === 'object' && module.exports) {\n    module.exports = factory()\n  } else {\n    root.moo = factory()\n  }\n}(this, function() {\n  'use strict';\n\n  var hasOwnProperty = Object.prototype.hasOwnProperty\n  var toString = Object.prototype.toString\n  var hasSticky = typeof new RegExp().sticky === 'boolean'\n\n  /***************************************************************************/\n\n  function isRegExp(o) { return o && toString.call(o) === '[object RegExp]' }\n  function isObject(o) { return o && typeof o === 'object' && !isRegExp(o) && !Array.isArray(o) }\n\n  function reEscape(s) {\n    return s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&')\n  }\n  function reGroups(s) {\n    var re = new RegExp('|' + s)\n    return re.exec('').length - 1\n  }\n  function reCapture(s) {\n    return '(' + s + ')'\n  }\n  function reUnion(regexps) {\n    if (!regexps.length) return '(?!)'\n    var source =  regexps.map(function(s) {\n      return \"(?:\" + s + \")\"\n    }).join('|')\n    return \"(?:\" + source + \")\"\n  }\n\n  function regexpOrLiteral(obj) {\n    if (typeof obj === 'string') {\n      return '(?:' + reEscape(obj) + ')'\n\n    } else if (isRegExp(obj)) {\n      // TODO: consider /u support\n      if (obj.ignoreCase) throw new Error('RegExp /i flag not allowed')\n      if (obj.global) throw new Error('RegExp /g flag is implied')\n      if (obj.sticky) throw new Error('RegExp /y flag is implied')\n      if (obj.multiline) throw new Error('RegExp /m flag is implied')\n      return obj.source\n\n    } else {\n      throw new Error('Not a pattern: ' + obj)\n    }\n  }\n\n  function pad(s, length) {\n    if (s.length > length) {\n      return s\n    }\n    return Array(length - s.length + 1).join(\" \") + s\n  }\n\n  function lastNLines(string, numLines) {\n    var position = string.length\n    var lineBreaks = 0;\n    while (true) {\n      var idx = string.lastIndexOf(\"\\n\", position - 1)\n      if (idx === -1) {\n        break;\n      } else {\n        lineBreaks++\n      }\n      position = idx\n      if (lineBreaks === numLines) {\n        break;\n      }\n      if (position === 0) {\n        break;\n      }\n    }\n    var startPosition = \n      lineBreaks < numLines ?\n      0 : \n      position + 1\n    return string.substring(startPosition).split(\"\\n\")\n  }\n\n  function objectToRules(object) {\n    var keys = Object.getOwnPropertyNames(object)\n    var result = []\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i]\n      var thing = object[key]\n      var rules = [].concat(thing)\n      if (key === 'include') {\n        for (var j = 0; j < rules.length; j++) {\n          result.push({include: rules[j]})\n        }\n        continue\n      }\n      var match = []\n      rules.forEach(function(rule) {\n        if (isObject(rule)) {\n          if (match.length) result.push(ruleOptions(key, match))\n          result.push(ruleOptions(key, rule))\n          match = []\n        } else {\n          match.push(rule)\n        }\n      })\n      if (match.length) result.push(ruleOptions(key, match))\n    }\n    return result\n  }\n\n  function arrayToRules(array) {\n    var result = []\n    for (var i = 0; i < array.length; i++) {\n      var obj = array[i]\n      if (obj.include) {\n        var include = [].concat(obj.include)\n        for (var j = 0; j < include.length; j++) {\n          result.push({include: include[j]})\n        }\n        continue\n      }\n      if (!obj.type) {\n        throw new Error('Rule has no type: ' + JSON.stringify(obj))\n      }\n      result.push(ruleOptions(obj.type, obj))\n    }\n    return result\n  }\n\n  function ruleOptions(type, obj) {\n    if (!isObject(obj)) {\n      obj = { match: obj }\n    }\n    if (obj.include) {\n      throw new Error('Matching rules cannot also include states')\n    }\n\n    // nb. error and fallback imply lineBreaks\n    var options = {\n      defaultType: type,\n      lineBreaks: !!obj.error || !!obj.fallback,\n      pop: false,\n      next: null,\n      push: null,\n      error: false,\n      fallback: false,\n      value: null,\n      type: null,\n      shouldThrow: false,\n    }\n\n    // Avoid Object.assign(), so we support IE9+\n    for (var key in obj) {\n      if (hasOwnProperty.call(obj, key)) {\n        options[key] = obj[key]\n      }\n    }\n\n    // type transform cannot be a string\n    if (typeof options.type === 'string' && type !== options.type) {\n      throw new Error(\"Type transform cannot be a string (type '\" + options.type + \"' for token '\" + type + \"')\")\n    }\n\n    // convert to array\n    var match = options.match\n    options.match = Array.isArray(match) ? match : match ? [match] : []\n    options.match.sort(function(a, b) {\n      return isRegExp(a) && isRegExp(b) ? 0\n           : isRegExp(b) ? -1 : isRegExp(a) ? +1 : b.length - a.length\n    })\n    return options\n  }\n\n  function toRules(spec) {\n    return Array.isArray(spec) ? arrayToRules(spec) : objectToRules(spec)\n  }\n\n  var defaultErrorRule = ruleOptions('error', {lineBreaks: true, shouldThrow: true})\n  function compileRules(rules, hasStates) {\n    var errorRule = null\n    var fast = Object.create(null)\n    var fastAllowed = true\n    var unicodeFlag = null\n    var groups = []\n    var parts = []\n\n    // If there is a fallback rule, then disable fast matching\n    for (var i = 0; i < rules.length; i++) {\n      if (rules[i].fallback) {\n        fastAllowed = false\n      }\n    }\n\n    for (var i = 0; i < rules.length; i++) {\n      var options = rules[i]\n\n      if (options.include) {\n        // all valid inclusions are removed by states() preprocessor\n        throw new Error('Inheritance is not allowed in stateless lexers')\n      }\n\n      if (options.error || options.fallback) {\n        // errorRule can only be set once\n        if (errorRule) {\n          if (!options.fallback === !errorRule.fallback) {\n            throw new Error(\"Multiple \" + (options.fallback ? \"fallback\" : \"error\") + \" rules not allowed (for token '\" + options.defaultType + \"')\")\n          } else {\n            throw new Error(\"fallback and error are mutually exclusive (for token '\" + options.defaultType + \"')\")\n          }\n        }\n        errorRule = options\n      }\n\n      var match = options.match.slice()\n      if (fastAllowed) {\n        while (match.length && typeof match[0] === 'string' && match[0].length === 1) {\n          var word = match.shift()\n          fast[word.charCodeAt(0)] = options\n        }\n      }\n\n      // Warn about inappropriate state-switching options\n      if (options.pop || options.push || options.next) {\n        if (!hasStates) {\n          throw new Error(\"State-switching options are not allowed in stateless lexers (for token '\" + options.defaultType + \"')\")\n        }\n        if (options.fallback) {\n          throw new Error(\"State-switching options are not allowed on fallback tokens (for token '\" + options.defaultType + \"')\")\n        }\n      }\n\n      // Only rules with a .match are included in the RegExp\n      if (match.length === 0) {\n        continue\n      }\n      fastAllowed = false\n\n      groups.push(options)\n\n      // Check unicode flag is used everywhere or nowhere\n      for (var j = 0; j < match.length; j++) {\n        var obj = match[j]\n        if (!isRegExp(obj)) {\n          continue\n        }\n\n        if (unicodeFlag === null) {\n          unicodeFlag = obj.unicode\n        } else if (unicodeFlag !== obj.unicode && options.fallback === false) {\n          throw new Error('If one rule is /u then all must be')\n        }\n      }\n\n      // convert to RegExp\n      var pat = reUnion(match.map(regexpOrLiteral))\n\n      // validate\n      var regexp = new RegExp(pat)\n      if (regexp.test(\"\")) {\n        throw new Error(\"RegExp matches empty string: \" + regexp)\n      }\n      var groupCount = reGroups(pat)\n      if (groupCount > 0) {\n        throw new Error(\"RegExp has capture groups: \" + regexp + \"\\nUse (?: … ) instead\")\n      }\n\n      // try and detect rules matching newlines\n      if (!options.lineBreaks && regexp.test('\\n')) {\n        throw new Error('Rule should declare lineBreaks: ' + regexp)\n      }\n\n      // store regex\n      parts.push(reCapture(pat))\n    }\n\n\n    // If there's no fallback rule, use the sticky flag so we only look for\n    // matches at the current index.\n    //\n    // If we don't support the sticky flag, then fake it using an irrefutable\n    // match (i.e. an empty pattern).\n    var fallbackRule = errorRule && errorRule.fallback\n    var flags = hasSticky && !fallbackRule ? 'ym' : 'gm'\n    var suffix = hasSticky || fallbackRule ? '' : '|'\n\n    if (unicodeFlag === true) flags += \"u\"\n    var combined = new RegExp(reUnion(parts) + suffix, flags)\n    return {regexp: combined, groups: groups, fast: fast, error: errorRule || defaultErrorRule}\n  }\n\n  function compile(rules) {\n    var result = compileRules(toRules(rules))\n    return new Lexer({start: result}, 'start')\n  }\n\n  function checkStateGroup(g, name, map) {\n    var state = g && (g.push || g.next)\n    if (state && !map[state]) {\n      throw new Error(\"Missing state '\" + state + \"' (in token '\" + g.defaultType + \"' of state '\" + name + \"')\")\n    }\n    if (g && g.pop && +g.pop !== 1) {\n      throw new Error(\"pop must be 1 (in token '\" + g.defaultType + \"' of state '\" + name + \"')\")\n    }\n  }\n  function compileStates(states, start) {\n    var all = states.$all ? toRules(states.$all) : []\n    delete states.$all\n\n    var keys = Object.getOwnPropertyNames(states)\n    if (!start) start = keys[0]\n\n    var ruleMap = Object.create(null)\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i]\n      ruleMap[key] = toRules(states[key]).concat(all)\n    }\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i]\n      var rules = ruleMap[key]\n      var included = Object.create(null)\n      for (var j = 0; j < rules.length; j++) {\n        var rule = rules[j]\n        if (!rule.include) continue\n        var splice = [j, 1]\n        if (rule.include !== key && !included[rule.include]) {\n          included[rule.include] = true\n          var newRules = ruleMap[rule.include]\n          if (!newRules) {\n            throw new Error(\"Cannot include nonexistent state '\" + rule.include + \"' (in state '\" + key + \"')\")\n          }\n          for (var k = 0; k < newRules.length; k++) {\n            var newRule = newRules[k]\n            if (rules.indexOf(newRule) !== -1) continue\n            splice.push(newRule)\n          }\n        }\n        rules.splice.apply(rules, splice)\n        j--\n      }\n    }\n\n    var map = Object.create(null)\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i]\n      map[key] = compileRules(ruleMap[key], true)\n    }\n\n    for (var i = 0; i < keys.length; i++) {\n      var name = keys[i]\n      var state = map[name]\n      var groups = state.groups\n      for (var j = 0; j < groups.length; j++) {\n        checkStateGroup(groups[j], name, map)\n      }\n      var fastKeys = Object.getOwnPropertyNames(state.fast)\n      for (var j = 0; j < fastKeys.length; j++) {\n        checkStateGroup(state.fast[fastKeys[j]], name, map)\n      }\n    }\n\n    return new Lexer(map, start)\n  }\n\n  function keywordTransform(map) {\n\n    // Use a JavaScript Map to map keywords to their corresponding token type\n    // unless Map is unsupported, then fall back to using an Object:\n    var isMap = typeof Map !== 'undefined'\n    var reverseMap = isMap ? new Map : Object.create(null)\n\n    var types = Object.getOwnPropertyNames(map)\n    for (var i = 0; i < types.length; i++) {\n      var tokenType = types[i]\n      var item = map[tokenType]\n      var keywordList = Array.isArray(item) ? item : [item]\n      keywordList.forEach(function(keyword) {\n        if (typeof keyword !== 'string') {\n          throw new Error(\"keyword must be string (in keyword '\" + tokenType + \"')\")\n        }\n        if (isMap) {\n          reverseMap.set(keyword, tokenType)\n        } else {\n          reverseMap[keyword] = tokenType\n        }\n      })\n    }\n    return function(k) {\n      return isMap ? reverseMap.get(k) : reverseMap[k]\n    }\n  }\n\n  /***************************************************************************/\n\n  var Lexer = function(states, state) {\n    this.startState = state\n    this.states = states\n    this.buffer = ''\n    this.stack = []\n    this.reset()\n  }\n\n  Lexer.prototype.reset = function(data, info) {\n    this.buffer = data || ''\n    this.index = 0\n    this.line = info ? info.line : 1\n    this.col = info ? info.col : 1\n    this.queuedToken = info ? info.queuedToken : null\n    this.queuedText = info ? info.queuedText: \"\";\n    this.queuedThrow = info ? info.queuedThrow : null\n    this.setState(info ? info.state : this.startState)\n    this.stack = info && info.stack ? info.stack.slice() : []\n    return this\n  }\n\n  Lexer.prototype.save = function() {\n    return {\n      line: this.line,\n      col: this.col,\n      state: this.state,\n      stack: this.stack.slice(),\n      queuedToken: this.queuedToken,\n      queuedText: this.queuedText,\n      queuedThrow: this.queuedThrow,\n    }\n  }\n\n  Lexer.prototype.setState = function(state) {\n    if (!state || this.state === state) return\n    this.state = state\n    var info = this.states[state]\n    this.groups = info.groups\n    this.error = info.error\n    this.re = info.regexp\n    this.fast = info.fast\n  }\n\n  Lexer.prototype.popState = function() {\n    this.setState(this.stack.pop())\n  }\n\n  Lexer.prototype.pushState = function(state) {\n    this.stack.push(this.state)\n    this.setState(state)\n  }\n\n  var eat = hasSticky ? function(re, buffer) { // assume re is /y\n    return re.exec(buffer)\n  } : function(re, buffer) { // assume re is /g\n    var match = re.exec(buffer)\n    // will always match, since we used the |(?:) trick\n    if (match[0].length === 0) {\n      return null\n    }\n    return match\n  }\n\n  Lexer.prototype._getGroup = function(match) {\n    var groupCount = this.groups.length\n    for (var i = 0; i < groupCount; i++) {\n      if (match[i + 1] !== undefined) {\n        return this.groups[i]\n      }\n    }\n    throw new Error('Cannot find token type for matched text')\n  }\n\n  function tokenToString() {\n    return this.value\n  }\n\n  Lexer.prototype.next = function() {\n    var index = this.index\n\n    // If a fallback token matched, we don't need to re-run the RegExp\n    if (this.queuedGroup) {\n      var token = this._token(this.queuedGroup, this.queuedText, index)\n      this.queuedGroup = null\n      this.queuedText = \"\"\n      return token\n    }\n\n    var buffer = this.buffer\n    if (index === buffer.length) {\n      return // EOF\n    }\n\n    // Fast matching for single characters\n    var group = this.fast[buffer.charCodeAt(index)]\n    if (group) {\n      return this._token(group, buffer.charAt(index), index)\n    }\n\n    // Execute RegExp\n    var re = this.re\n    re.lastIndex = index\n    var match = eat(re, buffer)\n\n    // Error tokens match the remaining buffer\n    var error = this.error\n    if (match == null) {\n      return this._token(error, buffer.slice(index, buffer.length), index)\n    }\n\n    var group = this._getGroup(match)\n    var text = match[0]\n\n    if (error.fallback && match.index !== index) {\n      this.queuedGroup = group\n      this.queuedText = text\n\n      // Fallback tokens contain the unmatched portion of the buffer\n      return this._token(error, buffer.slice(index, match.index), index)\n    }\n\n    return this._token(group, text, index)\n  }\n\n  Lexer.prototype._token = function(group, text, offset) {\n    // count line breaks\n    var lineBreaks = 0\n    if (group.lineBreaks) {\n      var matchNL = /\\n/g\n      var nl = 1\n      if (text === '\\n') {\n        lineBreaks = 1\n      } else {\n        while (matchNL.exec(text)) { lineBreaks++; nl = matchNL.lastIndex }\n      }\n    }\n\n    var token = {\n      type: (typeof group.type === 'function' && group.type(text)) || group.defaultType,\n      value: typeof group.value === 'function' ? group.value(text) : text,\n      text: text,\n      toString: tokenToString,\n      offset: offset,\n      lineBreaks: lineBreaks,\n      line: this.line,\n      col: this.col,\n    }\n    // nb. adding more props to token object will make V8 sad!\n\n    var size = text.length\n    this.index += size\n    this.line += lineBreaks\n    if (lineBreaks !== 0) {\n      this.col = size - nl + 1\n    } else {\n      this.col += size\n    }\n\n    // throw, if no rule with {error: true}\n    if (group.shouldThrow) {\n      var err = new Error(this.formatError(token, \"invalid syntax\"))\n      throw err;\n    }\n\n    if (group.pop) this.popState()\n    else if (group.push) this.pushState(group.push)\n    else if (group.next) this.setState(group.next)\n\n    return token\n  }\n\n  if (typeof Symbol !== 'undefined' && Symbol.iterator) {\n    var LexerIterator = function(lexer) {\n      this.lexer = lexer\n    }\n\n    LexerIterator.prototype.next = function() {\n      var token = this.lexer.next()\n      return {value: token, done: !token}\n    }\n\n    LexerIterator.prototype[Symbol.iterator] = function() {\n      return this\n    }\n\n    Lexer.prototype[Symbol.iterator] = function() {\n      return new LexerIterator(this)\n    }\n  }\n\n  Lexer.prototype.formatError = function(token, message) {\n    if (token == null) {\n      // An undefined token indicates EOF\n      var text = this.buffer.slice(this.index)\n      var token = {\n        text: text,\n        offset: this.index,\n        lineBreaks: text.indexOf('\\n') === -1 ? 0 : 1,\n        line: this.line,\n        col: this.col,\n      }\n    }\n    \n    var numLinesAround = 2\n    var firstDisplayedLine = Math.max(token.line - numLinesAround, 1)\n    var lastDisplayedLine = token.line + numLinesAround\n    var lastLineDigits = String(lastDisplayedLine).length\n    var displayedLines = lastNLines(\n        this.buffer, \n        (this.line - token.line) + numLinesAround + 1\n      )\n      .slice(0, 5)\n    var errorLines = []\n    errorLines.push(message + \" at line \" + token.line + \" col \" + token.col + \":\")\n    errorLines.push(\"\")\n    for (var i = 0; i < displayedLines.length; i++) {\n      var line = displayedLines[i]\n      var lineNo = firstDisplayedLine + i\n      errorLines.push(pad(String(lineNo), lastLineDigits) + \"  \" + line);\n      if (lineNo === token.line) {\n        errorLines.push(pad(\"\", lastLineDigits + token.col + 1) + \"^\")\n      }\n    }\n    return errorLines.join(\"\\n\")\n  }\n\n  Lexer.prototype.clone = function() {\n    return new Lexer(this.states, this.state)\n  }\n\n  Lexer.prototype.has = function(tokenType) {\n    return true\n  }\n\n\n  return {\n    compile: compile,\n    states: compileStates,\n    error: Object.freeze({error: true}),\n    fallback: Object.freeze({fallback: true}),\n    keywords: keywordTransform,\n  }\n\n}));\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.lexer = exports.states = void 0;\nconst moo_1 = __importDefault(require(\"moo\"));\nexports.states = {\n    body: {\n        doubleapos: { match: \"''\", value: () => \"'\" },\n        quoted: {\n            lineBreaks: true,\n            match: /'[{}#](?:[^]*?[^'])?'(?!')/u,\n            value: src => src.slice(1, -1).replace(/''/g, \"'\")\n        },\n        argument: {\n            lineBreaks: true,\n            match: /\\{\\s*[^\\p{Pat_Syn}\\p{Pat_WS}]+\\s*/u,\n            push: 'arg',\n            value: src => src.substring(1).trim()\n        },\n        octothorpe: '#',\n        end: { match: '}', pop: 1 },\n        content: { lineBreaks: true, match: /[^][^{}#']*/u }\n    },\n    arg: {\n        select: {\n            lineBreaks: true,\n            match: /,\\s*(?:plural|select|selectordinal)\\s*,\\s*/u,\n            next: 'select',\n            value: src => src.split(',')[1].trim()\n        },\n        'func-args': {\n            lineBreaks: true,\n            match: /,\\s*[^\\p{Pat_Syn}\\p{Pat_WS}]+\\s*,/u,\n            next: 'body',\n            value: src => src.split(',')[1].trim()\n        },\n        'func-simple': {\n            lineBreaks: true,\n            match: /,\\s*[^\\p{Pat_Syn}\\p{Pat_WS}]+\\s*/u,\n            value: src => src.substring(1).trim()\n        },\n        end: { match: '}', pop: 1 }\n    },\n    select: {\n        offset: {\n            lineBreaks: true,\n            match: /\\s*offset\\s*:\\s*\\d+\\s*/u,\n            value: src => src.split(':')[1].trim()\n        },\n        case: {\n            lineBreaks: true,\n            match: /\\s*(?:=\\d+|[^\\p{Pat_Syn}\\p{Pat_WS}]+)\\s*\\{/u,\n            push: 'body',\n            value: src => src.substring(0, src.indexOf('{')).trim()\n        },\n        end: { match: /\\s*\\}/u, pop: 1 }\n    }\n};\nexports.lexer = moo_1.default.states(exports.states);\n","\"use strict\";\n/**\n * An AST parser for ICU MessageFormat strings\n *\n * @packageDocumentation\n * @example\n * ```\n * import { parse } from '@messageformat/parser\n *\n * parse('So {wow}.')\n * [ { type: 'content', value: 'So ' },\n *   { type: 'argument', arg: 'wow' },\n *   { type: 'content', value: '.' } ]\n *\n *\n * parse('Such { thing }. { count, selectordinal, one {First} two {Second}' +\n *       '                  few {Third} other {#th} } word.')\n * [ { type: 'content', value: 'Such ' },\n *   { type: 'argument', arg: 'thing' },\n *   { type: 'content', value: '. ' },\n *   { type: 'selectordinal',\n *     arg: 'count',\n *     cases: [\n *       { key: 'one', tokens: [ { type: 'content', value: 'First' } ] },\n *       { key: 'two', tokens: [ { type: 'content', value: 'Second' } ] },\n *       { key: 'few', tokens: [ { type: 'content', value: 'Third' } ] },\n *       { key: 'other',\n *         tokens: [ { type: 'octothorpe' }, { type: 'content', value: 'th' } ] }\n *     ] },\n *   { type: 'content', value: ' word.' } ]\n *\n *\n * parse('Many{type,select,plural{ numbers}selectordinal{ counting}' +\n *                          'select{ choices}other{ some {type}}}.')\n * [ { type: 'content', value: 'Many' },\n *   { type: 'select',\n *     arg: 'type',\n *     cases: [\n *       { key: 'plural', tokens: [ { type: 'content', value: 'numbers' } ] },\n *       { key: 'selectordinal', tokens: [ { type: 'content', value: 'counting' } ] },\n *       { key: 'select', tokens: [ { type: 'content', value: 'choices' } ] },\n *       { key: 'other',\n *         tokens: [ { type: 'content', value: 'some ' }, { type: 'argument', arg: 'type' } ] }\n *     ] },\n *   { type: 'content', value: '.' } ]\n *\n *\n * parse('{Such compliance')\n * // ParseError: invalid syntax at line 1 col 7:\n * //\n * //  {Such compliance\n * //        ^\n *\n *\n * const msg = '{words, plural, zero{No words} one{One word} other{# words}}'\n * parse(msg)\n * [ { type: 'plural',\n *     arg: 'words',\n *     cases: [\n *       { key: 'zero', tokens: [ { type: 'content', value: 'No words' } ] },\n *       { key: 'one', tokens: [ { type: 'content', value: 'One word' } ] },\n *       { key: 'other',\n *         tokens: [ { type: 'octothorpe' }, { type: 'content', value: ' words' } ] }\n *     ] } ]\n *\n *\n * parse(msg, { cardinal: [ 'one', 'other' ], ordinal: [ 'one', 'two', 'few', 'other' ] })\n * // ParseError: The plural case zero is not valid in this locale at line 1 col 17:\n * //\n * //   {words, plural, zero{\n * //                   ^\n * ```\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parse = exports.ParseError = void 0;\nconst lexer_js_1 = require(\"./lexer.js\");\nconst getContext = (lt) => ({\n    offset: lt.offset,\n    line: lt.line,\n    col: lt.col,\n    text: lt.text,\n    lineBreaks: lt.lineBreaks\n});\nconst isSelectType = (type) => type === 'plural' || type === 'select' || type === 'selectordinal';\nfunction strictArgStyleParam(lt, param) {\n    let value = '';\n    let text = '';\n    for (const p of param) {\n        const pText = p.ctx.text;\n        text += pText;\n        switch (p.type) {\n            case 'content':\n                value += p.value;\n                break;\n            case 'argument':\n            case 'function':\n            case 'octothorpe':\n                value += pText;\n                break;\n            default:\n                throw new ParseError(lt, `Unsupported part in strict mode function arg style: ${pText}`);\n        }\n    }\n    const c = {\n        type: 'content',\n        value: value.trim(),\n        ctx: Object.assign({}, param[0].ctx, { text })\n    };\n    return [c];\n}\nconst strictArgTypes = [\n    'number',\n    'date',\n    'time',\n    'spellout',\n    'ordinal',\n    'duration'\n];\nconst defaultPluralKeys = ['zero', 'one', 'two', 'few', 'many', 'other'];\n/**\n * Thrown by {@link parse} on error\n *\n * @public\n */\nclass ParseError extends Error {\n    /** @internal */\n    constructor(lt, msg) {\n        super(lexer_js_1.lexer.formatError(lt, msg));\n    }\n}\nexports.ParseError = ParseError;\nclass Parser {\n    constructor(src, opt) {\n        var _a, _b, _c, _d;\n        this.lexer = lexer_js_1.lexer.reset(src);\n        this.cardinalKeys = (_a = opt === null || opt === void 0 ? void 0 : opt.cardinal) !== null && _a !== void 0 ? _a : defaultPluralKeys;\n        this.ordinalKeys = (_b = opt === null || opt === void 0 ? void 0 : opt.ordinal) !== null && _b !== void 0 ? _b : defaultPluralKeys;\n        this.strict = (_c = opt === null || opt === void 0 ? void 0 : opt.strict) !== null && _c !== void 0 ? _c : false;\n        this.strictPluralKeys = (_d = opt === null || opt === void 0 ? void 0 : opt.strictPluralKeys) !== null && _d !== void 0 ? _d : true;\n    }\n    parse() {\n        return this.parseBody(false, true);\n    }\n    checkSelectKey(lt, type, key) {\n        if (key[0] === '=') {\n            if (type === 'select')\n                throw new ParseError(lt, `The case ${key} is not valid with select`);\n        }\n        else if (type !== 'select') {\n            const keys = type === 'plural' ? this.cardinalKeys : this.ordinalKeys;\n            if (this.strictPluralKeys && keys.length > 0 && !keys.includes(key)) {\n                const msg = `The ${type} case ${key} is not valid in this locale`;\n                throw new ParseError(lt, msg);\n            }\n        }\n    }\n    parseSelect({ value: arg }, inPlural, ctx, type) {\n        const sel = { type, arg, cases: [], ctx };\n        if (type === 'plural' || type === 'selectordinal')\n            inPlural = true;\n        else if (this.strict)\n            inPlural = false;\n        for (const lt of this.lexer) {\n            switch (lt.type) {\n                case 'offset':\n                    if (type === 'select')\n                        throw new ParseError(lt, 'Unexpected plural offset for select');\n                    if (sel.cases.length > 0)\n                        throw new ParseError(lt, 'Plural offset must be set before cases');\n                    sel.pluralOffset = Number(lt.value);\n                    ctx.text += lt.text;\n                    ctx.lineBreaks += lt.lineBreaks;\n                    break;\n                case 'case': {\n                    this.checkSelectKey(lt, type, lt.value);\n                    sel.cases.push({\n                        key: lt.value,\n                        tokens: this.parseBody(inPlural),\n                        ctx: getContext(lt)\n                    });\n                    break;\n                }\n                case 'end':\n                    return sel;\n                /* istanbul ignore next: never happens */\n                default:\n                    throw new ParseError(lt, `Unexpected lexer token: ${lt.type}`);\n            }\n        }\n        throw new ParseError(null, 'Unexpected message end');\n    }\n    parseArgToken(lt, inPlural) {\n        const ctx = getContext(lt);\n        const argType = this.lexer.next();\n        if (!argType)\n            throw new ParseError(null, 'Unexpected message end');\n        ctx.text += argType.text;\n        ctx.lineBreaks += argType.lineBreaks;\n        if (this.strict &&\n            (argType.type === 'func-simple' || argType.type === 'func-args') &&\n            !strictArgTypes.includes(argType.value)) {\n            const msg = `Invalid strict mode function arg type: ${argType.value}`;\n            throw new ParseError(lt, msg);\n        }\n        switch (argType.type) {\n            case 'end':\n                return { type: 'argument', arg: lt.value, ctx };\n            case 'func-simple': {\n                const end = this.lexer.next();\n                if (!end)\n                    throw new ParseError(null, 'Unexpected message end');\n                /* istanbul ignore if: never happens */\n                if (end.type !== 'end')\n                    throw new ParseError(end, `Unexpected lexer token: ${end.type}`);\n                ctx.text += end.text;\n                if (isSelectType(argType.value.toLowerCase()))\n                    throw new ParseError(argType, `Invalid type identifier: ${argType.value}`);\n                return {\n                    type: 'function',\n                    arg: lt.value,\n                    key: argType.value,\n                    ctx\n                };\n            }\n            case 'func-args': {\n                if (isSelectType(argType.value.toLowerCase())) {\n                    const msg = `Invalid type identifier: ${argType.value}`;\n                    throw new ParseError(argType, msg);\n                }\n                let param = this.parseBody(this.strict ? false : inPlural);\n                if (this.strict && param.length > 0)\n                    param = strictArgStyleParam(lt, param);\n                return {\n                    type: 'function',\n                    arg: lt.value,\n                    key: argType.value,\n                    param,\n                    ctx\n                };\n            }\n            case 'select':\n                /* istanbul ignore else: never happens */\n                if (isSelectType(argType.value))\n                    return this.parseSelect(lt, inPlural, ctx, argType.value);\n                else\n                    throw new ParseError(argType, `Unexpected select type ${argType.value}`);\n            /* istanbul ignore next: never happens */\n            default:\n                throw new ParseError(argType, `Unexpected lexer token: ${argType.type}`);\n        }\n    }\n    parseBody(inPlural, atRoot) {\n        const tokens = [];\n        let content = null;\n        for (const lt of this.lexer) {\n            if (lt.type === 'argument') {\n                if (content)\n                    content = null;\n                tokens.push(this.parseArgToken(lt, inPlural));\n            }\n            else if (lt.type === 'octothorpe' && inPlural) {\n                if (content)\n                    content = null;\n                tokens.push({ type: 'octothorpe', ctx: getContext(lt) });\n            }\n            else if (lt.type === 'end' && !atRoot) {\n                return tokens;\n            }\n            else {\n                let value = lt.value;\n                if (!inPlural && lt.type === 'quoted' && value[0] === '#') {\n                    if (value.includes('{')) {\n                        const errMsg = `Unsupported escape pattern: ${value}`;\n                        throw new ParseError(lt, errMsg);\n                    }\n                    value = lt.text;\n                }\n                if (content) {\n                    content.value += value;\n                    content.ctx.text += lt.text;\n                    content.ctx.lineBreaks += lt.lineBreaks;\n                }\n                else {\n                    content = { type: 'content', value, ctx: getContext(lt) };\n                    tokens.push(content);\n                }\n            }\n        }\n        if (atRoot)\n            return tokens;\n        throw new ParseError(null, 'Unexpected message end');\n    }\n}\n/**\n * Parse an input string into an array of tokens\n *\n * @public\n * @remarks\n * The parser only supports the default `DOUBLE_OPTIONAL`\n * {@link http://www.icu-project.org/apiref/icu4c/messagepattern_8h.html#af6e0757e0eb81c980b01ee5d68a9978b | apostrophe mode}.\n */\nfunction parse(src, options = {}) {\n    const parser = new Parser(src, options);\n    return parser.parse();\n}\nexports.parse = parse;\n","import { parse } from '@messageformat/parser';\n\nfunction processTokens(tokens, mapText) {\n  if (!tokens.filter((token) => token.type !== \"content\").length) {\n    return tokens.map((token) => mapText(token.value));\n  }\n  return tokens.map((token) => {\n    if (token.type === \"content\") {\n      return mapText(token.value);\n    } else if (token.type === \"octothorpe\") {\n      return \"#\";\n    } else if (token.type === \"argument\") {\n      return [token.arg];\n    } else if (token.type === \"function\") {\n      const _param = token?.param?.[0];\n      if (_param) {\n        return [token.arg, token.key, _param.value.trim()];\n      } else {\n        return [token.arg, token.key];\n      }\n    }\n    const offset = token.pluralOffset;\n    const formatProps = {};\n    token.cases.forEach(({ key, tokens: tokens2 }) => {\n      const prop = key[0] === \"=\" ? key.slice(1) : key;\n      formatProps[prop] = processTokens(tokens2, mapText);\n    });\n    return [\n      token.arg,\n      token.type,\n      {\n        offset,\n        ...formatProps\n      }\n    ];\n  });\n}\nfunction compileMessage(message, mapText = (v) => v) {\n  try {\n    return processTokens(parse(message), mapText);\n  } catch (e) {\n    console.error(`${e.message} \n\nMessage: ${message}`);\n    return [message];\n  }\n}\n\nexport { compileMessage };\n","import {\n  InternationalizationConfigI,\n  LuwioInternationalizationI,\n} from \"@/contracts\";\nimport React, { PropsWithChildren } from \"react\";\nimport { I18n, Messages } from \"@lingui/core\";\nimport { I18nProvider } from \"@lingui/react\";\nimport { ILogger } from \"js-logger\";\nimport {\n  compileMessage,\n  CompiledMessage,\n} from \"@lingui/message-utils/compileMessage\";\n\nfunction toCompiledMessages(rawMessages: Record<string, string>): Messages {\n  const compiledMessages: Messages = {};\n\n  Object.keys(rawMessages).forEach((key) => {\n    const message = rawMessages[key];\n    compiledMessages[key] = compileMessage(message);\n  });\n\n  return compiledMessages;\n}\n\nexport class LuwioInternationalization implements LuwioInternationalizationI {\n  private readonly _internationalization: I18n;\n  private readonly _load: (language: string) => Promise<Record<string, string>>;\n  private readonly _logger: ILogger;\n\n  constructor(config: InternationalizationConfigI, logger: ILogger) {\n    this._logger = logger;\n    this._internationalization = config.i18n;\n    this._load = config.load;\n\n    this.change(config.initialLanguage);\n  }\n\n  private load = async (language: string) => {\n    return await this._load(language);\n  };\n\n  current() {\n    return this._internationalization.locale;\n  }\n\n  change(language: string) {\n    this._logger.info(`Changing language to ${language}`);\n\n    // Check if the language is already loaded\n    if (this.current() === language) {\n      this._logger.info(`Language is already ${language}`);\n      return;\n    }\n\n    this.load(language)\n      .then((messages) => {\n        this._logger.info(`Changing language to ${language}`);\n        this._logger.info(messages);\n\n        // Todo: check if this give performance issues.\n        const compiledMessages = toCompiledMessages(messages);\n        this._internationalization.load(language, compiledMessages);\n        this._internationalization.activate(language);\n      })\n      .catch((error) => {\n        this._logger.error(`Failed to change language to ${language}`);\n        this._logger.error(error);\n      });\n  }\n\n  t(key: string, variables?: Record<string, unknown>) {\n    return this._internationalization._(key, variables);\n  }\n\n  tdate(value: Date, format?: Intl.DateTimeFormatOptions) {\n    return this._internationalization.date(value, format);\n  }\n\n  tnumber(value: number, format?: Intl.DateTimeFormatOptions) {\n    return this._internationalization.number(value, format);\n  }\n\n  getProvider({ children }: PropsWithChildren): React.JSX.Element {\n    return (\n      <I18nProvider i18n={this._internationalization}>{children}</I18nProvider>\n    );\n  }\n}\n","import Logger from \"js-logger\";\n\nLogger.useDefaults({\n  defaultLevel: Logger.TRACE,\n  formatter: function (messages, context) {\n    // prefix each log message with a timestamp and the module name.\n    messages.unshift(new Date().toUTCString());\n    messages.unshift(\"Internationalization\");\n  },\n});\n\nexport const InternationalizationLogger = Logger.get(\"Internationalization\");\nInternationalizationLogger.setLevel(Logger.OFF);\n\nexport function enableInternationalizationLogger() {\n  InternationalizationLogger.setLevel(Logger.TRACE);\n}\n","import { I18n } from \"@lingui/core\";\nimport React, { createContext, FC, PropsWithChildren, useMemo } from \"react\";\nimport { LuwioInternationalizationI } from \"@/contracts\";\nimport { LuwioInternationalization } from \"@/domain\";\nimport { InternationalizationLogger } from \"@/logger\";\n\n// Context to provide the internationalization object\nexport const InternationalizationContext = createContext<\n  LuwioInternationalizationI | undefined\n>(undefined);\n\nexport interface InternationalizationProps extends PropsWithChildren {\n  initialLanguage: string;\n  loadMessages: (language: string) => Promise<Record<string, string>>;\n}\n\nexport const InternationalizationProvider: FC<InternationalizationProps> = (\n  props: InternationalizationProps,\n) => {\n  const { children, initialLanguage, loadMessages } = props;\n\n  const i18n = new I18n({\n    missing: (locale, key) => {\n      return `MISSING TRANSLATION: ${key} in ${locale}`;\n    },\n  });\n\n  // Create Internationalization instance\n  const Internationalization = new LuwioInternationalization(\n    {\n      i18n: i18n,\n      load: loadMessages,\n      initialLanguage: initialLanguage,\n    },\n    InternationalizationLogger,\n  );\n\n  // Provide the context and the children\n  return (\n    <InternationalizationContext.Provider value={Internationalization}>\n      {Internationalization.getProvider({ children })}\n    </InternationalizationContext.Provider>\n  );\n};\n","import { useContext } from \"react\";\nimport { InternationalizationContext } from \"@/context/internationalization-context\";\nimport { LuwioInternationalizationI } from \"@/contracts\";\n\nexport const useInternationalization = (): LuwioInternationalizationI => {\n  const context = useContext(InternationalizationContext);\n  if (!context) {\n    throw new Error(\n      \"useInternationalization must be used within a InternationalizationProvider\",\n    );\n  }\n  return context;\n};\n","import { createContext, FC, PropsWithChildren } from \"react\";\nimport { InternationalizationLogger } from \"@/logger\";\n\nexport interface LanguageDetectionContextType {\n  detectedLanguage: string;\n}\n\nexport const LanguageDetectionDefault = {\n  detectedLanguage: \"en\",\n};\n\nexport const LanguageDetectionContext =\n  createContext<LanguageDetectionContextType>(LanguageDetectionDefault);\n\nexport interface LanguageDetectionProviderProps extends PropsWithChildren {\n  detectLanguage: (fallback: string) => string;\n  fallbackLanguage: string;\n}\n\nexport const LanguageDetectionProvider: FC<LanguageDetectionProviderProps> = (\n  props: LanguageDetectionProviderProps,\n) => {\n  const { children, fallbackLanguage, detectLanguage } = props;\n\n  return (\n    <LanguageDetectionContext.Provider\n      value={{\n        detectedLanguage: detectLanguage(fallbackLanguage),\n      }}\n    >\n      {children}\n    </LanguageDetectionContext.Provider>\n  );\n};\n\nexport const detectLanguageFromUrl = (fallback: string): string => {\n  const url = new URL(window.location.href);\n  const pathname = url.pathname;\n\n  const code = pathname.split(\"/\")[1];\n\n  if (code.length !== 2) {\n    InternationalizationLogger.warn(\n      `Invalid length of language code detected from url: ${code}`,\n    );\n    InternationalizationLogger.info(\n      `fallback detected language to ${fallback}`,\n    );\n    return fallback;\n  }\n\n  if (!/^[a-zA-Z]{2}$/.test(code)) {\n    InternationalizationLogger.warn(\n      `Invalid language code detected from url: ${code}`,\n    );\n    InternationalizationLogger.info(\n      `fallback detected language to ${fallback}`,\n    );\n    return fallback;\n  }\n\n  if (code.toLowerCase() !== code) {\n    InternationalizationLogger.warn(\n      `Invalid language code containing uppercase values detected from url: ${code}`,\n    );\n    InternationalizationLogger.info(\n      `fallback detected language to ${fallback}`,\n    );\n    return fallback;\n  }\n\n  return code;\n};\n","import { useContext } from \"react\";\nimport { LanguageDetectionContext } from \"@/context/language-detection-context\";\n\nexport const useLanguageDetection = (): string => {\n  const context = useContext(LanguageDetectionContext);\n  return context.detectedLanguage;\n};\n"]}